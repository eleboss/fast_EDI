// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DVEC_H_
#define FLATBUFFERS_GENERATED_DVEC_H_

#include "flatbuffers/flatbuffers.h"

#include "dv-sdk/data/cvector.hpp"

struct DoubleVectorFlatbuffer;
struct DoubleVector;

struct VectorPackFlatbuffer;
struct VectorPack;

bool operator==(const DoubleVector &lhs, const DoubleVector &rhs);
bool operator==(const VectorPack &lhs, const VectorPack &rhs);

inline const flatbuffers::TypeTable *DoubleVectorTypeTable();

inline const flatbuffers::TypeTable *VectorPackTypeTable();

struct DoubleVector : public flatbuffers::NativeTable {
  typedef DoubleVectorFlatbuffer TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "DoubleVector";
  }
  int64_t timestamp;
  int64_t timestampStartOfFrame;
  int64_t timestampEndOfFrame;
  int64_t timestampStartOfExposure;
  int64_t timestampEndOfExposure;
  dv::cvector<double> pixels;
  bool trigger;
  DoubleVector()
      : timestamp(0),
        timestampStartOfFrame(0),
        timestampEndOfFrame(0),
        timestampStartOfExposure(0),
        timestampEndOfExposure(0),
        trigger(false) {
  }
// Generated Constructor
  DoubleVector(int64_t _timestamp, int64_t _timestampStartOfFrame, int64_t _timestampEndOfFrame, int64_t _timestampStartOfExposure, int64_t _timestampEndOfExposure, const dv::cvector<double> &_pixels, bool _trigger)
      : timestamp{_timestamp},
        timestampStartOfFrame{_timestampStartOfFrame},
        timestampEndOfFrame{_timestampEndOfFrame},
        timestampStartOfExposure{_timestampStartOfExposure},
        timestampEndOfExposure{_timestampEndOfExposure},
        pixels{_pixels},
        trigger{_trigger} {
  }
};

inline bool operator==(const DoubleVector &lhs, const DoubleVector &rhs) {
  return
      (lhs.timestamp == rhs.timestamp) &&
      (lhs.timestampStartOfFrame == rhs.timestampStartOfFrame) &&
      (lhs.timestampEndOfFrame == rhs.timestampEndOfFrame) &&
      (lhs.timestampStartOfExposure == rhs.timestampStartOfExposure) &&
      (lhs.timestampEndOfExposure == rhs.timestampEndOfExposure) &&
      (lhs.pixels == rhs.pixels) &&
      (lhs.trigger == rhs.trigger);
}

struct DoubleVectorFlatbuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleVector NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DoubleVectorTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "DoubleVector";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_TIMESTAMPSTARTOFFRAME = 6,
    VT_TIMESTAMPENDOFFRAME = 8,
    VT_TIMESTAMPSTARTOFEXPOSURE = 10,
    VT_TIMESTAMPENDOFEXPOSURE = 12,
    VT_PIXELS = 14,
    VT_TRIGGER = 16
  };
  /// Central timestamp (Âµs), corresponds to exposure midpoint.
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  /// Start of Frame (SOF) timestamp.
  int64_t timestampStartOfFrame() const {
    return GetField<int64_t>(VT_TIMESTAMPSTARTOFFRAME, 0);
  }
  /// End of Frame (EOF) timestamp.
  int64_t timestampEndOfFrame() const {
    return GetField<int64_t>(VT_TIMESTAMPENDOFFRAME, 0);
  }
  /// Start of Exposure (SOE) timestamp.
  int64_t timestampStartOfExposure() const {
    return GetField<int64_t>(VT_TIMESTAMPSTARTOFEXPOSURE, 0);
  }
  /// End of Exposure (EOE) timestamp.
  int64_t timestampEndOfExposure() const {
    return GetField<int64_t>(VT_TIMESTAMPENDOFEXPOSURE, 0);
  }
  /// Plot X coordinate.
  const flatbuffers::Vector<double> *pixels() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_PIXELS);
  }
  /// Flag to trig frame;
  bool trigger() const {
    return GetField<uint8_t>(VT_TRIGGER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMPSTARTOFFRAME) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMPENDOFFRAME) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMPSTARTOFEXPOSURE) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMPENDOFEXPOSURE) &&
           VerifyOffset(verifier, VT_PIXELS) &&
           verifier.VerifyVector(pixels()) &&
           VerifyField<uint8_t>(verifier, VT_TRIGGER) &&
           verifier.EndTable();
  }
  DoubleVector *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DoubleVector *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static void UnPackToFrom(DoubleVector *_o, const DoubleVectorFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver = nullptr);
  static flatbuffers::Offset<DoubleVectorFlatbuffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoubleVector* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DoubleVectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(DoubleVectorFlatbuffer::VT_TIMESTAMP, timestamp, 0);
  }
  void add_timestampStartOfFrame(int64_t timestampStartOfFrame) {
    fbb_.AddElement<int64_t>(DoubleVectorFlatbuffer::VT_TIMESTAMPSTARTOFFRAME, timestampStartOfFrame, 0);
  }
  void add_timestampEndOfFrame(int64_t timestampEndOfFrame) {
    fbb_.AddElement<int64_t>(DoubleVectorFlatbuffer::VT_TIMESTAMPENDOFFRAME, timestampEndOfFrame, 0);
  }
  void add_timestampStartOfExposure(int64_t timestampStartOfExposure) {
    fbb_.AddElement<int64_t>(DoubleVectorFlatbuffer::VT_TIMESTAMPSTARTOFEXPOSURE, timestampStartOfExposure, 0);
  }
  void add_timestampEndOfExposure(int64_t timestampEndOfExposure) {
    fbb_.AddElement<int64_t>(DoubleVectorFlatbuffer::VT_TIMESTAMPENDOFEXPOSURE, timestampEndOfExposure, 0);
  }
  void add_pixels(flatbuffers::Offset<flatbuffers::Vector<double>> pixels) {
    fbb_.AddOffset(DoubleVectorFlatbuffer::VT_PIXELS, pixels);
  }
  void add_trigger(bool trigger) {
    fbb_.AddElement<uint8_t>(DoubleVectorFlatbuffer::VT_TRIGGER, static_cast<uint8_t>(trigger), 0);
  }
  explicit DoubleVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleVectorBuilder &operator=(const DoubleVectorBuilder &);
  flatbuffers::Offset<DoubleVectorFlatbuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoubleVectorFlatbuffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleVectorFlatbuffer> CreateDoubleVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t timestampStartOfFrame = 0,
    int64_t timestampEndOfFrame = 0,
    int64_t timestampStartOfExposure = 0,
    int64_t timestampEndOfExposure = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> pixels = 0,
    bool trigger = false) {
  DoubleVectorBuilder builder_(_fbb);
  builder_.add_timestampEndOfExposure(timestampEndOfExposure);
  builder_.add_timestampStartOfExposure(timestampStartOfExposure);
  builder_.add_timestampEndOfFrame(timestampEndOfFrame);
  builder_.add_timestampStartOfFrame(timestampStartOfFrame);
  builder_.add_timestamp(timestamp);
  builder_.add_pixels(pixels);
  builder_.add_trigger(trigger);
  return builder_.Finish();
}

inline flatbuffers::Offset<DoubleVectorFlatbuffer> CreateDoubleVectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t timestampStartOfFrame = 0,
    int64_t timestampEndOfFrame = 0,
    int64_t timestampStartOfExposure = 0,
    int64_t timestampEndOfExposure = 0,
    const std::vector<double> *pixels = nullptr,
    bool trigger = false) {
  auto pixels__ = pixels ? _fbb.CreateVector<double>(*pixels) : 0;
  return CreateDoubleVector(
      _fbb,
      timestamp,
      timestampStartOfFrame,
      timestampEndOfFrame,
      timestampStartOfExposure,
      timestampEndOfExposure,
      pixels__,
      trigger);
}

flatbuffers::Offset<DoubleVectorFlatbuffer> CreateDoubleVector(flatbuffers::FlatBufferBuilder &_fbb, const DoubleVector *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VectorPack : public flatbuffers::NativeTable {
  typedef VectorPackFlatbuffer TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "VectorPack";
  }
  dv::cvector<DoubleVector> elements;
  VectorPack() {
  }
// Generated Constructor
  VectorPack(const dv::cvector<DoubleVector> &_elements)
      : elements{_elements} {
  }
};

inline bool operator==(const VectorPack &lhs, const VectorPack &rhs) {
  return
      (lhs.elements == rhs.elements);
}

struct VectorPackFlatbuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorPack NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *identifier = "DVEC";
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorPackTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "VectorPack";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DoubleVectorFlatbuffer>> *elements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DoubleVectorFlatbuffer>> *>(VT_ELEMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.VerifyVectorOfTables(elements()) &&
           verifier.EndTable();
  }
  VectorPack *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VectorPack *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static void UnPackToFrom(VectorPack *_o, const VectorPackFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver = nullptr);
  static flatbuffers::Offset<VectorPackFlatbuffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VectorPack* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VectorPackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DoubleVectorFlatbuffer>>> elements) {
    fbb_.AddOffset(VectorPackFlatbuffer::VT_ELEMENTS, elements);
  }
  explicit VectorPackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorPackBuilder &operator=(const VectorPackBuilder &);
  flatbuffers::Offset<VectorPackFlatbuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorPackFlatbuffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorPackFlatbuffer> CreateVectorPack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DoubleVectorFlatbuffer>>> elements = 0) {
  VectorPackBuilder builder_(_fbb);
  builder_.add_elements(elements);
  return builder_.Finish();
}

inline flatbuffers::Offset<VectorPackFlatbuffer> CreateVectorPackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DoubleVectorFlatbuffer>> *elements = nullptr) {
  auto elements__ = elements ? _fbb.CreateVector<flatbuffers::Offset<DoubleVectorFlatbuffer>>(*elements) : 0;
  return CreateVectorPack(
      _fbb,
      elements__);
}

flatbuffers::Offset<VectorPackFlatbuffer> CreateVectorPack(flatbuffers::FlatBufferBuilder &_fbb, const VectorPack *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline DoubleVector *DoubleVectorFlatbuffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DoubleVector();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DoubleVectorFlatbuffer::UnPackTo(DoubleVector *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  UnPackToFrom(_o, this, _resolver);
}

inline void DoubleVectorFlatbuffer::UnPackToFrom(DoubleVector *_o, const DoubleVectorFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver) {
  (void)_o;
  (void)_fb;
  (void)_resolver;
  { auto _e = _fb->timestamp(); _o->timestamp = _e; };
  { auto _e = _fb->timestampStartOfFrame(); _o->timestampStartOfFrame = _e; };
  { auto _e = _fb->timestampEndOfFrame(); _o->timestampEndOfFrame = _e; };
  { auto _e = _fb->timestampStartOfExposure(); _o->timestampStartOfExposure = _e; };
  { auto _e = _fb->timestampEndOfExposure(); _o->timestampEndOfExposure = _e; };
  { auto _e = _fb->pixels(); if (_e) { _o->pixels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pixels[_i] = _e->Get(_i); } } };
  { auto _e = _fb->trigger(); _o->trigger = _e; };
}

inline flatbuffers::Offset<DoubleVectorFlatbuffer> DoubleVectorFlatbuffer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoubleVector* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDoubleVector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DoubleVectorFlatbuffer> CreateDoubleVector(flatbuffers::FlatBufferBuilder &_fbb, const DoubleVector *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DoubleVector* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _timestamp = _o->timestamp;
  auto _timestampStartOfFrame = _o->timestampStartOfFrame;
  auto _timestampEndOfFrame = _o->timestampEndOfFrame;
  auto _timestampStartOfExposure = _o->timestampStartOfExposure;
  auto _timestampEndOfExposure = _o->timestampEndOfExposure;
  auto _pixels = _o->pixels.size() ? _fbb.CreateVector(_o->pixels.data(), _o->pixels.size()) : 0;
  auto _trigger = _o->trigger;
  return CreateDoubleVector(
      _fbb,
      _timestamp,
      _timestampStartOfFrame,
      _timestampEndOfFrame,
      _timestampStartOfExposure,
      _timestampEndOfExposure,
      _pixels,
      _trigger);
}

inline VectorPack *VectorPackFlatbuffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new VectorPack();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void VectorPackFlatbuffer::UnPackTo(VectorPack *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  UnPackToFrom(_o, this, _resolver);
}

inline void VectorPackFlatbuffer::UnPackToFrom(VectorPack *_o, const VectorPackFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver) {
  (void)_o;
  (void)_fb;
  (void)_resolver;
  { auto _e = _fb->elements(); if (_e) { _o->elements.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _e->Get(_i)->UnPackTo(&_o->elements[_i], _resolver); } } };
}

inline flatbuffers::Offset<VectorPackFlatbuffer> VectorPackFlatbuffer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VectorPack* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVectorPack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VectorPackFlatbuffer> CreateVectorPack(flatbuffers::FlatBufferBuilder &_fbb, const VectorPack *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VectorPack* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _elements = _o->elements.size() ? _fbb.CreateVector<flatbuffers::Offset<DoubleVectorFlatbuffer>> (_o->elements.size(), [](size_t i, _VectorArgs *__va) { return CreateDoubleVector(*__va->__fbb, &__va->__o->elements[i], __va->__rehasher); }, &_va ) : 0;
  return CreateVectorPack(
      _fbb,
      _elements);
}

inline const flatbuffers::TypeTable *DoubleVectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_DOUBLE, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "timestamp",
    "timestampStartOfFrame",
    "timestampEndOfFrame",
    "timestampStartOfExposure",
    "timestampEndOfExposure",
    "pixels",
    "trigger"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorPackTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DoubleVectorTypeTable
  };
  static const char * const names[] = {
    "elements"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const VectorPackFlatbuffer *GetVectorPack(const void *buf) {
  return flatbuffers::GetRoot<VectorPackFlatbuffer>(buf);
}

inline const VectorPackFlatbuffer *GetSizePrefixedVectorPack(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<VectorPackFlatbuffer>(buf);
}

inline const char *VectorPackIdentifier() {
  return "DVEC";
}

inline bool VectorPackBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, VectorPackIdentifier());
}

inline bool VerifyVectorPackBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<VectorPackFlatbuffer>(VectorPackIdentifier());
}

inline bool VerifySizePrefixedVectorPackBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<VectorPackFlatbuffer>(VectorPackIdentifier());
}

inline void FinishVectorPackBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<VectorPackFlatbuffer> root) {
  fbb.Finish(root, VectorPackIdentifier());
}

inline void FinishSizePrefixedVectorPackBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<VectorPackFlatbuffer> root) {
  fbb.FinishSizePrefixed(root, VectorPackIdentifier());
}

inline std::unique_ptr<VectorPack> UnPackVectorPack(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<VectorPack>(GetVectorPack(buf)->UnPack(res));
}

#endif  // FLATBUFFERS_GENERATED_DVEC_H_
